"""
This script implements functions that make requests to the Gitlab REST API.
The functions in this module are used to create an issue in the current sprint with a link to the failed pipeline.
"""

import os
import re
from typing import Tuple
import gitlab
from datetime import datetime, timezone

import gitlab.v4
import gitlab.v4.objects

issue_description_template = """
# CI pipeline failed


## Pipeline Details

[View Pipeline]({pipeline_url})

## Failed Jobs

{failed_jobs}

## Collected Errors

{collected_errors}

---
*This issue was auto-generated by the CI monitoring system.*
"""

issue_template = {
    "title": "CI failed for develop branch",
    "labels": ["CI", "Sprint"],
    "description": issue_description_template,
}


def title(commit_sha: str, days_since_commit: int) -> str:
    """
    Returns issue title string
    """
    return f"CI failed for commit {commit_sha[:7]} - Issue happening since {days_since_commit} Days"


def get_days_since_commit(project: gitlab.v4.objects.Project, commit_sha: str) -> int:
    "Returns number of days since the issue first occured"
    commit = project.commits.get(commit_sha)
    commit_time = datetime.strptime(commit.committed_date, "%Y-%m-%dT%H:%M:%S.%f%z")
    days_since_commit = (datetime.now(timezone.utc) - commit_time).days
    return days_since_commit


def create_issue_for_commit(
    project: gitlab.v4.objects.Project,
    ci_pipeline_url: str,
    ci_pipeline_id: int,
    commit_sha: str,
) -> gitlab.v4.objects.ProjectIssue:
    """Creates a new issue for a commit when a CI pipeline fails.

    Args:
        gl (gitlab.Gitlab): GitLab API client.
        project_id (str): The project ID to create the issue in.
        ci_pipeline_url (str): The URL of the failed CI pipeline.
        commit_sha (str): The commit SHA associated with the failed pipeline.

    Returns:
        gitlab.v4.objects.ProjectIssue: The created issue object.
    """
    days_since_commit = get_days_since_commit(project, commit_sha)

    issue_title = title(commit_sha, days_since_commit)
    issue_template["title"] = issue_title

    failed_jobs, collected_errors = analyze_logs(project, ci_pipeline_id)
    issue_description = issue_description_template.format(
        pipeline_url=ci_pipeline_url,
        failed_jobs=failed_jobs,
        collected_errors=collected_errors,
    )

    issue_template["description"] = issue_description

    issue = project.issues.create(issue_template)
    return issue


def update_issue_title(
    project: gitlab.v4.objects.Project,
    issue: gitlab.v4.objects.ProjectIssue,
    commit_sha: str,
) -> gitlab.v4.objects.ProjectIssue:
    """Updates the title of an existing issue based on the commit's timestamp.

    Args:
        gl (gitlab.Gitlab): GitLab API client.
        project_id (str): The project ID where the issue resides.
        issue (gitlab.v4.objects.ProjectIssue): The existing issue object to update.
        commit_sha (str): The commit SHA associated with the failed pipeline.

    Returns:
        None
    """
    days_since_commit = get_days_since_commit(project, commit_sha)
    issue.title = title(commit_sha, days_since_commit)
    return issue


def collect_errors_in_artifacts(job: gitlab.v4.objects.ProjectPipelineJob):
    """
    Go through all artifacts of the job, find error lines, and return a formatted string.

    :param job: GitLab job object
    :return: Formatted string with errors from the artifacts
    """
    error_summary = []
    
    


    for artifact in job.artifacts:
        artifact_name = artifact["file_name"]
        artifact_data = job.artifacts.get(artifact_name)

        # Read the artifact's content (assuming it's text-based, like a log file)
        log_content = artifact_data.decode(
            "utf-8", errors="ignore"
        )  # Decode to text, ignoring non-text bytes

        # Search for error lines containing keywords like 'ERROR' or 'Exception'
        error_lines = [
            line.strip()
            for line in log_content.splitlines()
            if re.search(r"(ERROR|Exception|Traceback|failed)", line, re.IGNORECASE)
        ]

        if error_lines:
            error_summary.append(
                f"**Errors in {artifact_name}:**\n```\n"
                + "\n".join(error_lines[:5])
                + "\n```"
            )

    return (
        "\n\n".join(error_summary)
        if error_summary
        else "No errors found in the artifacts."
    )


def analyze_logs(
    project: gitlab.v4.objects.Project, ci_pipeline_id: int
) -> Tuple[str, str]:
    # failed_jobs = project.pipelines.get(ci_pipeline_id).jobs.list(scope="failed")
    failed_jobs = project.pipelines.get(ci_pipeline_id).jobs.list(search="logs")
    failed_jobs_str = "\n".join(
        [f"- Job {job.id}: {job.name} (Failed)" for job in failed_jobs if job.status != "success"]
    )

    for job in failed_jobs:
        collected_errors = collect_errors_in_artifacts(job)

    return failed_jobs_str, collected_errors


def main():
    registry_token = os.getenv("REGISTRY_TOKEN")
    project_id = os.getenv("CI_PROJECT_ID")
    ci_pipeline_url = os.getenv("CI_PIPELINE_URL")
    ci_pipeline_id = os.getenv("CI_PIPELINE_ID")
    commit_sha = os.getenv("CI_COMMIT_SHA")
    
    gl = gitlab.Gitlab(
        url="https://codebase.helmholtz.cloud",
        private_token=registry_token,
        ssl_verify=False,
    )

    project_kaapana = gl.projects.get(id=project_id)
    existing_issues = project_kaapana.issues.list(
        state="opened", labels=["CI", "Sprint"], search=commit_sha
    )

    # result = analyze_logs(project_kaapana, ci_pipeline_id)
    if not existing_issues:
        issue = create_issue_for_commit(
            project_kaapana, ci_pipeline_url, ci_pipeline_id, commit_sha
        )

    else:
        issue = update_issue_title(project_kaapana, existing_issues[0], commit_sha)
    issue.save()


if __name__ == "__main__":
    main()